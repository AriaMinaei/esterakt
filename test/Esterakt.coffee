require('chai').use(require 'chai-fuzzy').should()

Esterakt = require '../lib/Esterakt'
Group = require '../lib/Group'
{prop} = Esterakt

describe 'Esterakt', ->

	describe "constructor()", ->

		it "should work"

	describe "addClass()", ->

		describe "should only accept classes", ->

			it "should accept classes", ->

				esterakt = new Esterakt

				class Something

					constructor: ->

				esterakt.addClass Something

			it "should throw error when not given a class", ->

				esterakt = new Esterakt

				( -> esterakt.addClass('hello')).should.throw()

		it "should not accept the same class twice", ->

			esterakt = new Esterakt

			class Something

					constructor: ->

			esterakt.addClass Something

			( -> esterakt.addClass Something).should.throw()

		it "should infer the class's name if the second argument is not present", ->

			esterakt = new Esterakt

			class Something

				constructor: ->

			esterakt.addClass Something

			esterakt._classes['Something'].should.equal Something

		it "should use the second argument as the class's name", ->

			esterakt = new Esterakt

			class Something

				constructor: ->

			esterakt.addClass Something, 'SomeOtherName'

			esterakt._classes['SomeOtherName'].should.equal Something

	describe "createGroup()", ->

		it "should generate a new group", ->

			esterakt = new Esterakt

			class Something

				constructor: ->

			esterakt.addClass Something

			group = esterakt.createGroup(10)

			group.should.be.instanceOf Group

	describe "general", ->

		# For now, Esterakt classes won't have any properties beyond
		# the ones generated by esterakt.
		#
		# There will be a Spec object that each group will use to generate
		# everything. Spec will be generated the first time a Esterakt::getGroup()
		# is called. If after that, another group is created, it'll use the same
		# Spec. If we want to add changes to an Esterakt after creating a group,
		# we can ::duplicate() it, and that will allow a new Spec to be generated.
		# Although the old groups will belong to the old Esterakt and won't have
		# the changes in the new Esterakt.


		it "should work", ->

			return



			group.setCount 50
			group.setCount 100
			group.setCount 10

			p = new group.classes.Point 5

			p._destruct()

			class PointView

				constructor: (@point, @eventsManager) ->

					@eventsManager.for('point:' + @point.index).on 'time-change', => do @_updateTime

				_updateTime: ->

					@el.x @point.time * 200

			new pointViewsGenerator.classes.PointView 5